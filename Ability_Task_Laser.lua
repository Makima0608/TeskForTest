---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by byteyang.
--- DateTime: 2025/3/1 11:09
---

local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")
local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local SPLuaUtility = require("Feature.StarP.Script.System.SPLuaUtility")

local IsValid = _SP.IsValid
local math_max = math.max
local ipairs = ipairs
local tonumber = tonumber
local string_format = string.format
local table_insert = table.insert

local function Log(...)
    _SP.Log("SPAbility", "[Ability_Task_Laser]", ...)
end

local function Warning(...)
    _SP.LogWarning("SPAbility", "[Ability_Task_Laser]", ...)
end

local function Error(...)
    _SP.LogError("SPAbility", "[Ability_Task_Laser]", ...)
end

---@class Ability_Task_Laser : USPAbilityTask
local Ability_Task_Laser = UE4.Class(nil, "Ability_Task_Laser")

function Ability_Task_Laser:OnTaskStartBP(Context)
    ---@type Ability_Task_LaserPad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        Warning("[OnTaskStartBP]", "ScratchPad is nil")
        return
    end

    -- 清空伤害计数
    Context:SetIntParameter("DamageCount", 0)

    -- 清理ScratchPad数据
    self:ClearScratchPad(ScratchPad)

    -- 初始化ScratchPad数据
    ScratchPad.DamageMap = {}
    ScratchPad.BuffMap = {}
    ScratchPad.Time = self:GetTaskStartTimeBP()
    ScratchPad.Owner = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_Self)
    ScratchPad.OwnerActorType = ScratchPad.Owner.GetSPActorType and ScratchPad.Owner:GetSPActorType()
    ScratchPad.Instigator = Context:GetInstigator() or ScratchPad.Owner
    ScratchPad.AbilityId = Context:GetAbilityId()
    ScratchPad.AbilityUniqueID = Context:GetAbilityUniqueID()
    ScratchPad.bInterrupt = false
    ScratchPad.bCanThisCollisionTriggerDodge = true
    ScratchPad.TargetActors = Context:GetTargetActors():ToTable()

    Log("[OnTaskStartBP]", "AbilityId:", ScratchPad.AbilityId)

    -- 初始化伤害配置
    self:InitDamageConfig(ScratchPad)
    -- 初始化碰撞范围数据
    self:InitSweepRange(ScratchPad)
    -- 计算最大伤害次数
    self:CalcMaxDamageCount(ScratchPad)

    -- 碰撞并伤害
    self:CollisionAndDamage(ScratchPad, Context, true)
end

function Ability_Task_Laser:OnTaskTickBP(Context, DeltaTime)
    ---@type Ability_Task_LaserPad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        Warning("[OnTaskTickBP]", "ScratchPad is nil")
        return
    end

    --计算时间
    ScratchPad.Time = ScratchPad.Time + DeltaTime

    -- 碰撞并伤害
    self:CollisionAndDamage(ScratchPad, Context)
end

function Ability_Task_Laser:OnTaskEndBP(Context, Result)
    ---@type Ability_Task_LaserPad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        Warning("[OnTaskEndBP]", "ScratchPad is nil")
        return
    end

    ScratchPad.Time = self:GetTaskEndTimeBP()

    if _SP.IsClient then
        self:StopParticleEffect(ScratchPad)
        self:StopHitParticleEffect(ScratchPad)
        self:PlayEndingParticleEffect(ScratchPad, Context)
    end

    -- 清理ScratchPad数据
    self:ClearScratchPad(ScratchPad)
end

---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:ResetScratchPadBP(ScratchPad)
    -- 清理ScratchPad数据
    self:ClearScratchPad(ScratchPad)
end

---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:ClearScratchPad(ScratchPad)
    ScratchPad.DamageMap = nil
    ScratchPad.BuffMap = nil
    ScratchPad.Time = nil
    ScratchPad.Owner = nil
    ScratchPad.OwnerActorType = nil
    ScratchPad.Instigator = nil
    ScratchPad.AbilityId = nil
    ScratchPad.AbilityUniqueID = nil
    ScratchPad.bInterrupt = nil
    ScratchPad.bCanThisCollisionTriggerDodge = nil
    ScratchPad.HighPingPawns = nil
    ScratchPad.DamageConfig = nil
    ScratchPad.HitConfig = nil
    ScratchPad.Orientation = nil
    ScratchPad.DamageResults = nil
    ScratchPad.StartLoc = nil
    ScratchPad.EndLoc = nil
    ScratchPad.SpawnTransform = nil
    ScratchPad.CollisionResults = nil
    ScratchPad.QueryResult = nil
    ScratchPad.QueryResultActor = nil
    ScratchPad.QueryHitResultPoint = nil
    ScratchPad.Distance = nil
    ScratchPad.SpawnedEffect = nil
    ScratchPad.SpawnedHitBodyEffect = nil
    ScratchPad.SpawnedHitSceneEffect = nil
    ScratchPad.SpawnParticleTransform = nil
    ScratchPad.FixedParticleSpawnTransform = nil
    ScratchPad.StartRotation = nil
    ScratchPad.EndRotation = nil
end

function Ability_Task_Laser:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.Laser)
end

---InitDamageConfig
---初始化伤害配置
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:InitDamageConfig(ScratchPad)
    local DamageId = -1
    local AbilityId = ScratchPad.AbilityId
    local abilityData = _SP.SPGameplayUtils:GetSkillData(AbilityId)
    if abilityData then
        local DamageIds = abilityData.damageIds or {}
        DamageId = tonumber(DamageIds[self.DamageIndex + 1])
        if DamageId == nil then
            Warning("Ability Damage Config Error ", string_format("Ability [%s] config DamageIndex [%s], damage list length = [%s]", AbilityId, self.DamageIndex, #DamageIds))
        end
    end

    ScratchPad.DamageId = DamageId
    ScratchPad.DamageConfig = _SP.SPConfigManager:GetConfigById("SPDamageConfigTable", "SPDamageConfig", DamageId)
    local HitId = ScratchPad.DamageConfig and ScratchPad.DamageConfig.hitId or 0
    ScratchPad.HitConfig = _SP.SPConfigManager:GetConfigById("SPHitConfigTable", "SPHitConfig", HitId)
end

---InitSweepRange
---初始化碰撞范围数据
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:InitSweepRange(ScratchPad)
    if self.IsSweeping then
        local Owner = ScratchPad.Owner
        local TargetActors = ScratchPad.TargetActors

        local FirstTarget = next(TargetActors) and TargetActors[1]
        if _SP.IsValid(Owner) then
            if Owner:IsA(UE4.ASPGameSummonBase) then
                Owner = _SP.SPAbilityUtils.FindFinalSummonMaster(Owner)
            end
        end

        if not _SP.IsValid(Owner) or not _SP.IsValid(FirstTarget) then
            self.IsSweeping = false
            Log("[InitSweepRange] not valid firstTarget or not valid owner!")
            return
        end

        --计算射线扫射开始位置和结束位置
        local TargetLocation = FirstTarget:K2_GetActorLocation()
        local OwnerLocation = Owner:K2_GetActorLocation()
        local OwnerToTarget = TargetLocation - OwnerLocation
        OwnerToTarget:Normalize()
        local CapsuleRadius = Owner:SPGetCapsuleRadius()
        local StartLocVector = OwnerToTarget * (CapsuleRadius + self.SweepStartLength)
        local EndLocVector = OwnerToTarget * (CapsuleRadius + self.SweepLength + self.SweepStartLength)

        local StartLoc = OwnerLocation + StartLocVector
        local EndLoc = OwnerLocation + EndLocVector

        ScratchPad.StartLoc = StartLoc
        ScratchPad.EndLoc = EndLoc
    end
end

---CalcMaxDamageCount
---计算最大伤害次数
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:CalcMaxDamageCount(ScratchPad)
    local Owner = ScratchPad.Owner
    local AbilityId = ScratchPad.AbilityId
    local AbilityUniqueID = ScratchPad.AbilityUniqueID

    SPAbilityUtils.DispatchMaxDamageCount(AbilityId, AbilityUniqueID, Owner, 0, self.Interval, self:GetDuration())
end

---CollisionAndDamage
---碰撞并伤害
---@param ScratchPad Ability_Task_LaserPad
---@param Context UAbleAbilityContext
---@param bStart boolean
function Ability_Task_Laser:CollisionAndDamage(ScratchPad, Context, bStart)
    -- 更新碰撞范围数据
    self:UpdateSpawnTransform(ScratchPad, Context, bStart)
    -- 碰撞检测
    self:DoQuery(ScratchPad, Context)
    -- 造成伤害
    self:DoDamage(ScratchPad, Context)
    -- 粒子特效
    if _SP.IsClient then
        if bStart then
            self:PlayParticleEffect(ScratchPad, Context)
            self:PlayHitParticleEffect(ScratchPad, Context)
        end
        self:RefreshParticle(ScratchPad, Context)
        self:RefreshHitParticle(ScratchPad, Context)
    end
end

---UpdateSpawnTransform
---更新碰撞范围数据
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:UpdateSpawnTransform(ScratchPad, Context, bStart)
    local SpawnTransform
    if not self.bTickCollisionChange and ScratchPad.SpawnTransform then
        -- use saved transform
        SpawnTransform = ScratchPad.SpawnTransform
    else
        -- use transform from the ability
        SpawnTransform = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.QueryLocation)
        ScratchPad.SpawnTransform = SpawnTransform
    end

    ScratchPad.TraceStart = SpawnTransform.Translation

    --计算射线扫射移动
    if self.IsSweeping then
        if bStart then
            --获取射线扫射开始位置的旋转和结束位置的旋转
            local StartRotation = UE4.UKismetMathLibrary.FindLookAtRotation(SpawnTransform.Translation, ScratchPad.StartLoc)
            local EndRotation = UE4.UKismetMathLibrary.FindLookAtRotation(SpawnTransform.Translation, ScratchPad.EndLoc)
            SpawnTransform.Rotation = StartRotation:ToQuat()
            ScratchPad.StartRotation = StartRotation
            ScratchPad.EndRotation = EndRotation
            ScratchPad.SpawnParticleTransform = SpawnTransform
        else
            local DurationTime = self:GetDuration()
            local ElapsedTime = ScratchPad.Time - self:GetTaskStartTimeBP()
            local Progress = DurationTime > 0 and (ElapsedTime / DurationTime) or 0
            -- 如果配置曲线，就读曲线配置，曲线归一化
            if self.SweepChangeCurve and self.SweepChangeCurve:IsA(UE4.UCurveFloat.StaticClass()) then
                Progress = self.SweepChangeCurve:GetFloatValue(Progress)
            end
            local currentRotation = UE4.UKismetMathLibrary.RLerp(ScratchPad.StartRotation, ScratchPad.EndRotation, Progress)
            SpawnTransform.Rotation = currentRotation:ToQuat()
            ScratchPad.SpawnParticleTransform = SpawnTransform
        end
    end

    ScratchPad.Orientation = SpawnTransform.Rotation:ToRotator()
end

local RevisedImpactPoint = function(ImpactPoint, StartPoint, Orientation)
    if not ImpactPoint then
        return
    end
    local Direction = UE4.UKismetMathLibrary.Conv_RotatorToVector(Orientation)
    local t = 0
    if Direction.Z ~= 0 then
        t = (ImpactPoint.Z - StartPoint.Z) / Direction.Z
    end
    local FinalPoint = UE4.FVector(
            StartPoint.X + t * Direction.X,
            StartPoint.Y + t * Direction.Y,
            StartPoint.Z + t * Direction.Z
    )
    return FinalPoint
end

---DoQuery
---碰撞检测
---@param ScratchPad Ability_Task_LaserPad
---@param Context UAbleAbilityContext
function Ability_Task_Laser:DoQuery(ScratchPad, Context)
    local Owner = ScratchPad.Owner
    local TraceStart = ScratchPad.TraceStart
    local Orientation = ScratchPad.Orientation

    local ObjectTypes = _SP.SPAbilityUtils.GetObjectTypesPresent(Context, self.CollisionChannel.Present, self.CollisionChannel.Channels)

    local HitResults = UE4.TArray(UE4.FHitResult)
    UE4.USPAbilityFunctionLibrary.DoCollisionDetect(Context, Owner, HitResults, self.CollisionShape, ObjectTypes, TraceStart, Orientation, true, self.ShapeRange.HalfExtents, self.ShapeRange.Radius, self.ShapeRange.ConeRadius,
            self.ShapeRange.ConeLength, self.ShapeRange.HalfHeight, self.ShapeRange.CylinderAngle, self.ShapeRange.CylinderInnerRadius, self.ShapeRange.CylinderOuterRadius, self.ShapeRange.CylinderHeight, _SP.IsDSorStandalone and _SP.DS._bShowDebugCollision, true, true, true)

    Log("[DoQuery]", "[DamageDebug]", "AbilityId:", ScratchPad.AbilityId, "HitResults:", HitResults:Length())

    -- 配置过滤
    UE4.USPAbilityFunctionLibrary.DoCollisionFilterByHitResult(self.Filter.m_Filters, Context, HitResults)

    -- 根据起点到碰撞点距离做升序排序
    UE4.USPAbilityFunctionLibrary.SortHitResultsByImpactPointDistance(TraceStart, HitResults)

    ScratchPad.CollisionResults = HitResults:ToTable()

    -- 特效位置
    ScratchPad.QueryResult = nil
    ScratchPad.QueryResultActor = nil
    ScratchPad.QueryHitResultPoint = nil
    -- ScratchPad.QueryHitResultPointModified = nil

    if #ScratchPad.CollisionResults > 0 then
        local HitResult = ScratchPad.CollisionResults[1]
        local ImpactPoint = HitResult.ImpactPoint
        ScratchPad.QueryResult = HitResult
        ScratchPad.QueryResultActor = HitResult.Actor
        ScratchPad.QueryHitResultPoint = UE4.FVector(
            ImpactPoint.X,
            ImpactPoint.Y,
            ImpactPoint.Z
        )
        -- ScratchPad.QueryHitResultPointModified = RevisedImpactPoint(ScratchPad.QueryHitResultPoint, TraceStart, Orientation)
    end

    Log("[DoQuery]", "[DamageDebug]", "AbilityId:", ScratchPad.AbilityId, "CollisionResults:", #ScratchPad.CollisionResults, "QueryResultActor:", ScratchPad.QueryResultActor and ScratchPad.QueryResultActor:GetName(), "QueryHitResultPoint:", tostring(ScratchPad.QueryHitResultPoint))

    if self.m_Verbose then
        for Index, CollisionResult in ipairs(ScratchPad.CollisionResults) do
            Log("[DoQuery]", "[DamageDebug]", "AbilityId:", ScratchPad.AbilityId, "Index:", Index, "Actor:", CollisionResult.Actor and CollisionResult.Actor:GetName())
        end
    end
end

---DoDamage
---造成伤害
---@param ScratchPad Ability_Task_LaserPad
---@param Context UAbleAbilityContext
function Ability_Task_Laser:DoDamage(ScratchPad, Context)
    -- 伤害过滤
    self:FilterDamage(ScratchPad)

    -- 造成伤害
    local DamageCount = #ScratchPad.DamageResults
    if DamageCount > 0 then
        -- 造成伤害
        local AbilityDamageComponent = UE4.USPAbilityFunctionLibrary.GetAbilityDamageComponent(ScratchPad.Instigator)
        if IsValid(AbilityDamageComponent) then
            -- 生成伤害信息
            local DamageInfo = self:GeneratedDamage(ScratchPad, AbilityDamageComponent)

            AbilityDamageComponent:DoDamage(DamageInfo)
        end

        -- 伤害计数
        local SuperimposedDamageCount = Context:GetIntParameter("SuperimposedDamageCount") or 0
        SuperimposedDamageCount = SuperimposedDamageCount + DamageCount
        Context:SetIntParameter("SuperimposedDamageCount", SuperimposedDamageCount)
        Context:SetIntParameter("DamageCount", DamageCount)
    end

    Log("[DoDamage]", "[DamageDebug]", "AbilityId:", ScratchPad.AbilityId, "DamageId:", ScratchPad.DamageId, "DamageCount:", DamageCount, "AbilityUniqueID:", ScratchPad.AbilityUniqueID)
end

---FilterDamage
---过滤伤害
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:FilterDamage(ScratchPad)
    local DamageResults = {}
    local CollisionResults

    --- 非扫射模式使用第一个HitResult即可
    if not self.IsSweeping then
        CollisionResults = ScratchPad.QueryResult and {ScratchPad.QueryResult} or {}
    else
        CollisionResults = ScratchPad.CollisionResults
    end

    for _, HitResult in ipairs(CollisionResults) do
        ---间隔时间
        if self:FilterDamage_Interval(HitResult, ScratchPad) then goto continue end
        ---死亡
        if self:FilterDamage_Dead(HitResult, ScratchPad) then goto continue end
        ---Actor类型
        if self:FilterDamage_ActorType(HitResult, ScratchPad) then goto continue end

        table_insert(DamageResults, HitResult)

        ::continue::
    end

    ScratchPad.DamageResults = DamageResults
end

---FilterDamage_Dead
---过滤伤害_死亡
---@param HitResult FHitResult
function Ability_Task_Laser:FilterDamage_Dead(HitResult)
    local HitActor = HitResult.Actor
    if IsValid(HitActor) then
        if HitActor.GetIsDead and HitActor:GetIsDead() then
            return true
        end
    else
        return true
    end
    return false
end

---FilterDamage_Interval
---过滤伤害_间隔时间
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:FilterDamage_Interval(HitResult, ScratchPad)
    if self.Interval > 0 then
        local HitActor = HitResult.Actor
        if IsValid(HitActor) then
            local DamageMap = ScratchPad.DamageMap
            local DamageInfo = DamageMap[HitActor]
            if DamageInfo and (ScratchPad.Time - DamageInfo.DamagedTime) < self.Interval then
                return true
            end
        end
    end
    return false
end

---FilterDamage_ActorType
---过滤伤害_Actor类型
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:FilterDamage_ActorType(HitResult, ScratchPad)
    local HitActor = HitResult.Actor
    if HitActor.GetCanBeDamaged and not HitActor:GetCanBeDamaged() then
        Log("[FilterDamage_ActorType]", "AbilityId:", ScratchPad.AbilityId, "GetCanBeDamaged")
        return true
    end

    if ScratchPad.OwnerActorType and ScratchPad.OwnerActorType == UE4.ESPActorType.Summon then
        -- 如果释放碰撞检测的是召唤物，确保召唤物自己的主人不会被自己打
        local Owner = ScratchPad.Owner
        if Owner.GetSummonMaster then
            local SummonMaster = Owner:GetSummonMaster()
            if HitActor == SummonMaster then
                Log("[FilterDamage_ActorType]", "AbilityId:", ScratchPad.AbilityId, "SummonMaster")
                return true
            end
        end
        -- 如果释放碰撞检测的是召唤物，确保召唤物所依附的目标不会受到伤害
        if self.SkipSummonAttachmentActorDamage then
            if Owner.GetAttachParentActor then
                local ParentActor = Owner:GetAttachParentActor()
                if HitActor == ParentActor then
                    Log("[FilterDamage_ActorType]", "AbilityId:", ScratchPad.AbilityId, "ParentActor")
                    return true
                end
            end
        end
    else
        if HitActor.GetSPActorType then
            local ActorType = HitActor:GetSPActorType()
            if ActorType == UE4.ESPActorType.Player or
                    ActorType == UE4.ESPActorType.Pet then
                if not self.bCheckSameTeam and
                        not UE4.USPGameLibrary.IsInDifferentTeam(ScratchPad.Owner, HitActor) then
                    Log("[FilterDamage_ActorType]", "AbilityId:", ScratchPad.AbilityId, "IsInDifferentTeam")
                    return true
                end
            end
        end
    end

    return false
end

---GeneratedDamage
---生成伤害
---@param ScratchPad Ability_Task_LaserPad
---@param AbilityDamageComponent USPAbilityDamageComponent
function Ability_Task_Laser:GeneratedDamage(ScratchPad, AbilityDamageComponent)
    ---@type USPAbilityDamage
    local DamageInfo = UE4.USPAbilityDamage.MakeDamage(AbilityDamageComponent)
    DamageInfo.HighPingPawns = ScratchPad.HighPingPawns

    local Struct = UE4.FSPAbilityDamageStruct()
    Struct.AbilityId = ScratchPad.AbilityId
    Struct.DamageId = ScratchPad.DamageId
    Struct.Owner = ScratchPad.Owner
    Struct.Instigator = ScratchPad.Instigator
    Struct.Orientation = ScratchPad.Orientation
    Struct.UniqueID = ScratchPad.AbilityUniqueID

    local DamageMap = ScratchPad.DamageMap
    for _, HitResult in ipairs(ScratchPad.DamageResults) do
        local HitActor = HitResult.Actor
        local Damage = DamageMap[HitActor]
        if not Damage then
            Damage = {}
            DamageMap[HitActor] = Damage
        end
        Damage.DamagedTime = ScratchPad.Time


        ---@type FSPAbilityDamageResult
        local DamageResult = UE4.FSPAbilityDamageResult()
        DamageResult.HitResult = HitResult

        ---Buff
        self:GeneratedDamage_Buff(ScratchPad, DamageResult)
        ---PerfectDodge
        self:GeneratedDamage_PerfectDodge(ScratchPad, DamageResult)

        Struct.DamageArray:Add(DamageResult)
    end

    DamageInfo:SetStruct(Struct)

    return DamageInfo
end

---GeneratedDamage_Buff
---生成伤害_Buff
---@param ScratchPad Ability_Task_LaserPad
---@param DamageResult FSPAbilityDamageResult
function Ability_Task_Laser:GeneratedDamage_Buff(ScratchPad, DamageResult)
    if self.AddBuffWhenDamage then
        local HitActor = DamageResult.HitResult.Actor
        local bAddBuff = true
        if not self.AddbuffRepeat then
            if ScratchPad.BuffMap[HitActor] then
                bAddBuff = false
            else
                ScratchPad.BuffMap[HitActor] = true
            end
        end
        if bAddBuff then
            DamageResult.BuffId = self.BuffID
            DamageResult.BuffLayer = self.BuffLayer
            DamageResult.bIndexBuffFromSkill = self.IndexBuffFromSkill

            Log("[GeneratedDamage_Buff]", "BuffID:", self.BuffID)
        end
    end
end

---GeneratedDamage_PerfectDodge
---生成伤害_完美闪避
---@param ScratchPad Ability_Task_LaserPad
---@param DamageResult FSPAbilityDamageResult
function Ability_Task_Laser:GeneratedDamage_PerfectDodge(ScratchPad, DamageResult)
    local HitActor = DamageResult.HitResult.Actor
    -- 如果是玩家被打 就去完美闪避组件做判断
    if IsValid(HitActor) and HitActor:IsA(UE4.ASPGameCharacterBase) then
        local dmgConfig = _SP.SPConfigManager:GetConfigById("SPDamageConfigTable", "SPDamageConfig", ScratchPad.DamageId)
        if dmgConfig and dmgConfig.canTriggerPerfectDodge and dmgConfig.canTriggerPerfectDodge > 0 then
            if ScratchPad.bCanThisCollisionTriggerDodge then
                local PerfectDodgeComponent = HitActor:GetComponentByClass(UE4.USPPerfectDodgeComponent:StaticClass())
                if IsValid(PerfectDodgeComponent) and PerfectDodgeComponent:GetPerfectDodgeCheckTime() then
                    if dmgConfig.canTriggerPerfectDodge == SPAbilityUtils.ESPCollisionTriggerDodgeType.Once then
                        ScratchPad.bCanThisCollisionTriggerDodge = false
                    end

                    DamageResult.bPerfectDodge = true

                    Log("[DamageEffect_PerfectDodge]", "GeneratedDamage_PerfectDodge")
                end
            end
        end
    end
end

---PlayParticleEffect
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:PlayParticleEffect(ScratchPad, Context)
    if not self.EffectTemplate then
        return
    end

    ScratchPad.SpawnedEffect = nil

    self:SpawnOrModifyPSC(ScratchPad, Context)
end

---RefreshParticle
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:RefreshParticle(ScratchPad, Context)
    if _SP.IsValid(ScratchPad.SpawnedEffect) then
        self:SpawnOrModifyPSC(ScratchPad, Context)
    end
end

---StopParticleEffect
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:StopParticleEffect(ScratchPad)
    if _SP.IsValid(ScratchPad.SpawnedEffect) then
        if self.DetachOnStop then
            ScratchPad.SpawnedEffect:K2_DetachFromComponent(UE4.EAttachmentRule.KeepWorld, UE4.EAttachmentRule.KeepWorld, UE4.EAttachmentRule.KeepWorld, true)
        end
        UE4.USPGameLibrary.DeactivateParticleSystem(ScratchPad.SpawnedEffect)
        ScratchPad.SpawnedEffect = nil
    end
end

---SpawnOrModifyPSC
---@param ScratchPad Ability_Task_LaserPad
---@param Context UAbleAbilityContext
function Ability_Task_Laser:SpawnOrModifyPSC(ScratchPad, Context)
    local Target = ScratchPad.Owner
    local SpawnTransform
    if not self.bTickParticleChange and ScratchPad.FixedParticleSpawnTransform then
        -- 使用固定的特效生成位置
        SpawnTransform = ScratchPad.FixedParticleSpawnTransform
    else
        SpawnTransform = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.ParticleLocation)
        ScratchPad.FixedParticleSpawnTransform = SpawnTransform
    end

    if self.IsSweeping then
        local currentRotation = self.SweepRotatorOffset + ScratchPad.SpawnParticleTransform.Rotation:ToRotator()
        ScratchPad.SpawnParticleTransform.Rotation = currentRotation:ToQuat()
        SpawnTransform = ScratchPad.SpawnParticleTransform
    end

    -- calculate scale
    local ModifiedScale = self:CalculateParticleScale(ScratchPad.QueryHitResultPoint, SpawnTransform, ScratchPad)
    SpawnTransform.Scale3D.X = self.CanEditScaleX and ModifiedScale or self.Scale
    SpawnTransform.Scale3D.Y = self.CanEditScaleY and ModifiedScale or self.Scale
    SpawnTransform.Scale3D.Z = self.CanEditScaleZ and ModifiedScale or self.Scale

    if _SP.IsValid(ScratchPad.SpawnedEffect) then
        --just modify transform and particle length
        ScratchPad.SpawnedEffect:K2_SetWorldTransform(SpawnTransform)
        -- 有些激光特效有参数需要修改，比如冰龙BOSS激光
        ScratchPad.SpawnedEffect:SetFloatParameter("emitter_rate_scale", ModifiedScale)
        ScratchPad.SpawnedEffect:SetVectorParameter("size_scale",UE4.FVector(ModifiedScale, 1, 1))
    else
        -- spawn new PSC
        local EffectTemplate = self.EffectTemplate
        local SpawnedEffect
        local Location = self.QueryLocation
        if EffectTemplate then
            if self.AttachToSocket then
                local AttachComponent = Target:GetComponentByClass(UE4.USceneComponent:StaticClass())
                SpawnedEffect = UE4.UGameplayStatics.SpawnEmitterAttached(EffectTemplate, AttachComponent,
                        Location.m_Socket, SpawnTransform.Translation,
                        SpawnTransform.Rotation:ToRotator(),
                        SpawnTransform.Scale3D,
                        UE4.EAttachLocation.KeepWorldPosition)
            else
                SpawnedEffect = UE4.UGameplayStatics.SpawnEmitterAtLocation(Target:GetWorld(), EffectTemplate, SpawnTransform.Translation, SpawnTransform.Rotation:ToRotator())
                if _SP.IsValid(SpawnedEffect) then
                    SpawnedEffect:K2_SetWorldTransform(SpawnTransform)
                end
            end
            SpawnedEffect.TranslucencySortPriority = self.RenderSortPriority
        end
        if _SP.IsValid(SpawnedEffect) then
            ScratchPad.SpawnedEffect = SpawnedEffect
            -- 有些激光特效有参数需要修改，比如冰龙BOSS激光
            ScratchPad.SpawnedEffect:SetFloatParameter("emitter_rate_scale", ModifiedScale)
            ScratchPad.SpawnedEffect:SetVectorParameter("size_scale", UE4.FVector(ModifiedScale, 1, 1))

        end
    end
end

function Ability_Task_Laser:CalculateParticleScale(QueryHitResultPoint, Transform, ScratchPad)
    if self.ParticleNormalizeLength <= 0 then
        return 1
    end
    if QueryHitResultPoint then
        local Distance = UE4.UKismetMathLibrary.Vector_Distance(Transform.Translation, QueryHitResultPoint)
        ScratchPad.Distance = math.min(Distance, self.ParticleMaxLength)
        --射线扫射不需要根据检测目标改变射线长度
        if self.ParticleNormalizeLength ~= 0 and not self.IsSweeping then
            return math.min(Distance / self.ParticleNormalizeLength, self.ParticleMaxLength / self.ParticleNormalizeLength)
        end
    end
    return self.ParticleMaxLength / self.ParticleNormalizeLength
end

---PlayHitParticleEffect
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:PlayHitParticleEffect(ScratchPad, Context)
    ScratchPad.SpawnedHitBodyEffect = nil
    ScratchPad.SpawnedHitSceneEffect = nil

    self:SpawnOrModifyHitPSC(ScratchPad, Context)
end

---RefreshHitParticle
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:RefreshHitParticle(ScratchPad, Context)
    if ScratchPad.QueryHitResultPoint or ScratchPad.SpawnedHitBodyEffect or ScratchPad.SpawnedHitSceneEffect then
        self:SpawnOrModifyHitPSC(ScratchPad, Context)
    end
end

---StopHitParticleEffect
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:StopHitParticleEffect(ScratchPad)
    if ScratchPad.SpawnedHitBodyEffect then
        UE4.USPGameLibrary.DeactivateParticleSystem(ScratchPad.SpawnedHitBodyEffect)
        ScratchPad.SpawnedHitBodyEffect = nil
    end

    if ScratchPad.SpawnedHitSceneEffect then
        UE4.USPGameLibrary.DeactivateParticleSystem(ScratchPad.SpawnedHitSceneEffect)
        ScratchPad.SpawnedHitSceneEffect = nil
    end
end

---PlayEndingParticleEffect
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:PlayEndingParticleEffect(ScratchPad, Context)
    if self.EndingEffectTemplate then
        local SpawnTransform
        if self.IsSweeping then
            SpawnTransform = ScratchPad.SpawnParticleTransform
        else
            SpawnTransform = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.ParticleLocation)
        end
        local ModifiedScale = self:CalculateParticleScale(ScratchPad.QueryHitResultPoint, SpawnTransform, ScratchPad)
        SpawnTransform.Scale3D.X = self.CanEditScaleX and ModifiedScale or self.Scale
        SpawnTransform.Scale3D.Y = self.CanEditScaleY and ModifiedScale or self.Scale
        SpawnTransform.Scale3D.Z = self.CanEditScaleZ and ModifiedScale or self.Scale
        local SpawnedEffect
        local Target = ScratchPad.Owner
        if self.AttachToSocket then
            local AttachComponent = Target:GetComponentByClass(UE4.USceneComponent:StaticClass())
            SpawnedEffect = UE4.UGameplayStatics.SpawnEmitterAttached(self.EndingEffectTemplate, AttachComponent, self.QueryLocation.m_Socket, SpawnTransform.Translation, SpawnTransform.Rotation:ToRotator(), SpawnTransform.Scale3D, UE4.EAttachLocation.KeepWorldPosition)
        else
            SpawnedEffect = UE4.UGameplayStatics.SpawnEmitterAtLocation(Target:GetWorld(), self.EndingEffectTemplate, SpawnTransform.Translation, SpawnTransform.Rotation:ToRotator())
            if _SP.IsValid(SpawnedEffect) then
                SpawnedEffect:K2_SetWorldTransform(SpawnTransform)
            end
        end
        if _SP.IsValid(SpawnedEffect) then
            SpawnedEffect.TranslucencySortPriority = self.RenderSortPriority
        end
    end
end

---SpawnOrModifyHitPSC
---@param ScratchPad Ability_Task_LaserPad
function Ability_Task_Laser:SpawnOrModifyHitPSC(ScratchPad, Context)
    if not self.HitSceneEffectTemplate and not self.HitBodyEffectTemplate then
        return
    end
    local SpawnTransform = ScratchPad.SpawnTransform
    local Target = ScratchPad.Owner
    local HitEffectTemplate
    -- 先判断击中的Actor类型，决定使用的特效
    local HitActor = ScratchPad.QueryResultActor
    if HitActor and self.HitBodyEffectTemplate and (HitActor:Cast(UE4.ASPGameCharacterBase) or HitActor:Cast(UE4.ASPGameMonsterBase) or HitActor:Cast(UE4.ASP_ChoppableActor)) then
        -- 击中玩家或星兽或植被
        HitEffectTemplate = self.HitBodyEffectTemplate
        if ScratchPad.SpawnedHitSceneEffect ~= nil then
            -- HitActor切换，需要清除另一种特效
            UE4.USPGameLibrary.DeactivateParticleSystem(ScratchPad.SpawnedHitSceneEffect)
            ScratchPad.SpawnedHitSceneEffect = nil
        end
        if ScratchPad.QueryHitResultPoint then
            local SpawnLocation = ScratchPad.QueryHitResultPoint

            -- 根据QueryRotation旋转受击特效
            local SpawnRotation = UE4.FRotator(0, 0, 0)
            SpawnRotation.Pitch = self.BodyEffectRotatePitch and -SpawnTransform.Rotation:ToRotator().Pitch or 0
            SpawnRotation.Yaw = self.BodyEffectRotateYaw and SpawnTransform.Rotation:ToRotator().Yaw or 0
            SpawnRotation.Roll = self.BodyEffectRotateRoll and SpawnTransform.Rotation:ToRotator().Roll or 0

            local SpawnScale = UE4.FVector(1, 1, 1)
            local SpawnTransForm = UE4.FTransform(SpawnRotation:ToQuat(), SpawnLocation)

            if _SP.IsValid(ScratchPad.SpawnedHitBodyEffect) then
                -- 特效存在，更新位置
                ScratchPad.SpawnedHitBodyEffect:K2_SetWorldTransform(SpawnTransForm)
            else
                -- 特效不存在，生成特效
                local SpawnedHitEffect = UE4.UGameplayStatics.SpawnEmitterAtLocation(
                        Target:GetWorld(), HitEffectTemplate, SpawnLocation,
                        SpawnRotation, SpawnScale)
                if _SP.IsValid(SpawnedHitEffect) then
                    ScratchPad.SpawnedHitBodyEffect = SpawnedHitEffect
                end
                -- UE4.UKismetSystemLibrary.DrawDebugSphere(self, SpawnLocation, 100, 12, UE4.FLinearColor(1, 0.3, 0, 1), 2, 5)
            end
        else
            -- 没有impactpoint，销毁HitEffect
            self:StopHitParticleEffect(Context)
        end
    elseif self.HitSceneEffectTemplate then
        -- 击中其他
        HitEffectTemplate = self.HitSceneEffectTemplate
        if ScratchPad.SpawnedHitBodyEffect ~= nil then
            -- HitActor切换，需要清除另一种特效
            UE4.USPGameLibrary.DeactivateParticleSystem(ScratchPad.SpawnedHitBodyEffect)
            ScratchPad.SpawnedHitBodyEffect = nil
        end
        local Distance = ScratchPad.Distance
        if ScratchPad.QueryHitResultPoint and Distance and Distance > 0 then
            local QueryHitResultPointModified = SpawnTransform.Translation + SpawnTransform.Rotation:ToRotator():GetForwardVector()* ScratchPad.Distance
            -- 根据QueryRotation旋转受击特效
            local SpawnRotation = UE4.FRotator(0, 0, 0)
            SpawnRotation.Pitch = self.SceneEffectRotatePitch and -SpawnTransform.Rotation:ToRotator().Pitch or 0
            SpawnRotation.Yaw = self.SceneEffectRotateYaw and SpawnTransform.Rotation:ToRotator().Yaw or 0
            SpawnRotation.Roll = self.SceneEffectRotateRoll and SpawnTransform.Rotation:ToRotator().Roll or 0

            local SpawnScale = UE4.FVector(1, 1, 1)
            local SpawnTransForm = UE4.FTransform(SpawnRotation:ToQuat(), QueryHitResultPointModified)

            if _SP.IsValid(ScratchPad.SpawnedHitSceneEffect) then
                -- 特效存在，更新位置
                ScratchPad.SpawnedHitSceneEffect:K2_SetWorldTransform(SpawnTransForm)
            else
                -- 特效不存在，生成特效
                local SpawnedHitEffect = UE4.UGameplayStatics.SpawnEmitterAtLocation(
                        Target:GetWorld(), HitEffectTemplate, QueryHitResultPointModified,
                        SpawnRotation, SpawnScale)
                if _SP.IsValid(SpawnedHitEffect) then
                    ScratchPad.SpawnedHitSceneEffect = SpawnedHitEffect
                end
            end
            -- UE4.UKismetSystemLibrary.DrawDebugSphere(self, SpawnLocation, 100, 12, UE4.FLinearColor(1, 0.3, 0, 1), 2, 5)
        else
            -- 没有impactpoint，销毁HitEffect
            self:StopHitParticleEffect(Context)
        end
    end
end

return Ability_Task_Laser